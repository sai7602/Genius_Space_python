# Завдання 1: Принцип єдиного обов'язку (Single Responsibility Principle - SRP)

# Спроектуйте і реалізуйте клас "Користувач" (User), який відповідає принципу SRP. В цьому класі повинні бути методи для створення користувача, оновлення даних користувача та видалення користувача. Переконайтеся, що кожен метод відповідає за одну конкретну функцію.

class User:
    def __init__(self, name, email, password):
        self.name = name
        self.email = email
        self.password = password

    def create_user(self):
        pass

    def update_user(self):
        pass

    def delete_user(self):
        pass    
# Завдання 2: Принцип відкритості/закритості (Open/Closed Principle - OCP)

# Створіть інтерфейс "Фігура" (Shape) та два класи, які реалізують цей інтерфейс, наприклад, "Коло" (Circle) та "Прямокутник" (Rectangle). Потім додайте новий клас, який розраховує площу будь-якої фігури, не модифікуючи існуючі класи. Використовуйте принцип OCP для розширення функціональності.

class Shape:
    def calculate_area(self):
        pass

class Circle(Shape):
    def calculate_area(self):
        pass

class Rectangle(Shape):
    def calculate_area(self):
        pass        
# Завдання 3: Принцип підстановки Лісков (Liskov Substitution Principle - LSP)

# Створіть ієрархію класів для геометричних фігур, де кожен підклас (наприклад, "Квадрат" і "Круг") може замінити базовий клас "Фігура" без порушення функціональності. Переконайтеся, що ці підкласи можуть використовуватися замість базового класу у всіх контекстах без проблем.

# Завдання 4: Принцип інтерфейсу користувача (Interface Segregation Principle - ISP)

# Розробіть інтерфейс "Мережевий принтер" (NetworkPrinter), який включає методи для друку, сканування та копіювання. Потім створіть два класи: "Принтер" (Printer) та "Сканер" (Scanner), які реалізують цей інтерфейс та використовують лише ті методи, які їм потрібні. Переконайтеся, що жоден з класів не має пустого методу.

# Завдання 5: Принцип залежностей (Dependency Inversion Principle - DIP)

# Використовуючи принцип DIP, переробіть код залежностей у вашому проекті так, щоб він використовував абстракції та інтерфейси замість конкретних реалізацій. Переконайтеся, що класи залежностей не знають про конкретну реалізацію інших класів.